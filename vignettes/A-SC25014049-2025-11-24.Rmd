---
title: "Homework-2025.11.24"
author: "By SC25014049"
date: "2025/11/24"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to R-package-Homework-2025.11.24}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question1 
Exercise 6:
Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?

翻译:
实现Map（）和vapply（）的组合，以创建一个lapply（）变量，该变量并行迭代所有输入，并将其输出存储在一个向量（或矩阵）中。该函数应采用哪些参数？

## Answer1
首先根据题意，先编写一个函数实现两个函数的组合，其中要提供参数有四个如下：
FUN: 要应用的函数
...: 要并行迭代的输入对象（向量、列表等）
FUN.VALUE: 输出类型的模板（向量或矩阵）
USE.NAMES: 逻辑值，是否使用名称（可选，默认 TRUE）
```{r,echo=FALSE}

lapply_2 <- function(FUN, ..., FUN.VALUE, USE.NAMES = TRUE) {

  temp_result <- Map(FUN, ...)
  
  if (is.matrix(FUN.VALUE)) {

    final_output <- vapply(
      temp_result, 
      function(x) if (is.matrix(x)) x else matrix(x, nrow = nrow(FUN.VALUE)),
      FUN.VALUE
    )
    return(final_output)
  } else {

    final_output <- vapply(temp_result, identity, FUN.VALUE, USE.NAMES = USE.NAMES)
    return(final_output)
  }
}
```


## Question2
Make a faster version of chisq.test() that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying chisq.test() or by coding from the mathematical definition (http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test).

翻译；
制作一个更快版本的chisq.test（），仅当输入是两个没有缺失值的数字向量时才计算卡方检验统计量。您可以尝试简化chisq.test（）或通过从数学定义（http：//zh.wikipedia.org/wiki/Pearson%27s_chi-squared_test).

## Answer2

由于只计算卡方检验统计量，简化了计算过程，因此可以省略许多步骤，首先只处理必要的输入验证。
采用快速版本的chisq_test与原版运行，结果如下：
```{r,echo=FALSE}

library(rbenchmark)
chisq_2 <- function(P4k9q, R2m6s) {
  if (length(P4k9q) != length(R2m6s)) {
    stop("Vectors must have the same length")
  }
  
  if (any(is.na(P4k9q)) || any(is.na(R2m6s))) {
    stop("Vectors must not contain missing values")
  }

  J8d1f <- table(P4k9q, R2m6s)
  
  W5t2r <- rowSums(J8d1f)
  C9n4p <- colSums(J8d1f)
  T6b8v <- sum(J8d1f)
  
  E3k7z <- outer(W5t2r, C9n4p) / T6b8v
  
  Q1x5y <- sum((J8d1f - E3k7z)^2 / E3k7z)
  
  return(Q1x5y)
}

# test
set.seed(123)
test_vector1 <- sample(1:3, 100, replace = TRUE)
test_vector2 <- sample(1:2, 100, replace = TRUE)

fast_result <- chisq_2(test_vector1, test_vector2)

standard_result <- chisq.test(test_vector1, test_vector2)$statistic

df1 = data.frame(fast_result,standard_result,abs(fast_result - standard_result))
colnames(df1) <- c("快速版本卡方统计量", "标准版本卡方统计量","结果差异")
knitr::kable(df1)
```
由上述结果，看出函数实现是成功的，

```{r,echo=FALSE}
F7j2k_results <- benchmark(
  "标准chisq.test" = {
    chisq.test(test_vector1, test_vector2)$statistic
  },
  "快速chisq" = {
    chisq_2(test_vector1, test_vector2)
  },
  replications = 100,
  columns = c("test", "replications", "elapsed", "relative", "user.self", "sys.self")
)

# print(F7j2k_results)
knitr::kable(F7j2k_results)

```
由上表可以看出快速版本有效提升了速度。


## Question3 
Can you make a faster version of table() for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?

翻译:
对于两个不含缺失值的整数向量输入的情况，能否编写一个比 table() 更快的版本？能否用它来加快您的卡方检验的速度？

## Answer3

首先，标准的table()函数功能强大，但它需要处理各种数据类型、缺失值等情况,可能比较复杂。我们可以只需要处理两个不含缺失值的整数向量情况就行，进行优化。同时使用快速版的替换我们问题2中的chisq_2函数，用rbenchmark进行加速，结果如下：


```{r,echo=FALSE}
library(rbenchmark)

fast_table_int <- function(X9s8d, Y7k9f) {

  if (!is.integer(X9s8d) || !is.integer(Y7k9f)) {
    stop("Vectors must be integer type")
  }
  

  A7s9d <- sort(unique(X9s8d))
  B8j7k <- sort(unique(Y7k9f))
  X_idx <- match(X9s8d, A7s9d)
  Y_idx <- match(Y7k9f, B8j7k)

  R8n7m <- length(A7s9d)
  C9p8o <- length(B8j7k)
  U6h5g <- (X_idx - 1) * C9p8o + Y_idx
  
  S5l4k <- tabulate(U6h5g, nbins = R8n7m * C9p8o)
  dim(S5l4k) <- c(R8n7m, C9p8o)

  rownames(S5l4k) <- as.character(A7s9d)
  colnames(S5l4k) <- as.character(B8j7k)
  
  return(S5l4k)
}

chisq_2 <- function(P4k9q, R2m6s) {
  if (length(P4k9q) != length(R2m6s)) {
    stop("Vectors must have the same length")
  }
  
  if (any(is.na(P4k9q)) || any(is.na(R2m6s))) {
    stop("Vectors must not contain missing values")
  }

  J8d1f <- fast_table_int(P4k9q, R2m6s)
  
  W5t2r <- rowSums(J8d1f)
  C9n4p <- colSums(J8d1f)
  T6b8v <- sum(J8d1f)
  
  E3k7z <- outer(W5t2r, C9n4p) / T6b8v
  
  Q1x5y <- sum((J8d1f - E3k7z)^2 / E3k7z)
  
  return(Q1x5y)
}

set.seed(123)
test_vec1 <- as.integer(sample(1:100, size = 1e6, replace = TRUE))
test_vec2 <- as.integer(sample(1:50, size = 1e6, replace = TRUE))

chisq_2_original <- function(P4k9q, R2m6s) {
  if (length(P4k9q) != length(R2m6s)) {
    stop("Vectors must have the same length")
  }
  
  if (any(is.na(P4k9q)) || any(is.na(R2m6s))) {
    stop("Vectors must not contain missing values")
  }

  J8d1f <- table(P4k9q, R2m6s)
  
  W5t2r <- rowSums(J8d1f)
  C9n4p <- colSums(J8d1f)
  T6b8v <- sum(J8d1f)
  
  E3k7z <- outer(W5t2r, C9n4p) / T6b8v
  
  Q1x5y <- sum((J8d1f - E3k7z)^2 / E3k7z)
  
  return(Q1x5y)
}

bench_res <- benchmark(
  "原始版(table())" = chisq_2_original(test_vec1, test_vec2),
  "加速版(fast_table)" = chisq_2(test_vec1, test_vec2),
  replications = 1,
  columns = c("test", "elapsed"),
  order = "elapsed"
)

knitr::kable(bench_res)

cat("\n结果一致性：", all.equal(
  chisq_2_original(test_vec1, test_vec2),
  chisq_2(test_vec1, test_vec2)
), "\n")
```


