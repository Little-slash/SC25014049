---
title: "Homework-2025.10.20"
author: "By SC25014049"
date: "2025/10/20"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to R-package-Homework-2025.10.20}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question1 
Of N = 1000 hypotheses, 950 are null and 50 are alternative. The p-value under any null hypothesis is uniformly distributed (use the R function runif), and the p-value under any alternative hypothesis follows the beta distribution with parameter 0.1 and 1 (use the R function rbeta). Obtain Bonferroni adjusted p-values and B-H adjusted p-values. Calculate FWER, FDR, and TPR under nominal level $\alpha$ = 0.1 for each of the two adjustment methods based on m = 10000 simulation replicates. You should output the 6 numbers to a 3 × 2 table (column names: Bonferroni correction, B-H correction; row names: FWER, FDR, TPR). Comment the results.

## Answer1

首先空假设是(0,1)上均匀分布的，备择假设则是服从beta分布，由于模拟次数为10000次，所以每次都需要重新生成p值，并进行两种方法矫正，最后取均值，输出结果如下表所示:
```{r,echo=FALSE}
set.seed(123)
m<-1000
sim <- 10000
alpha <-0.1

null_n <- 950
al_n <- 50


fwer_1 <- numeric(sim)
fwer_2 <- numeric(sim)

fdr_1 <- numeric(sim)
fdr_2 <- numeric(sim)

tpr_1 <- numeric(sim)
tpr_2 <- numeric(sim)

for (i in 1:sim){
  null_p <- runif(null_n)
  al_p <-  rbeta(al_n,0.1,1)
  
  truth_results <- c(rep(0, null_n), rep(1, al_n))
  p_values <- c(null_p, al_p)
  
  #bonfer
  
  p1 <- p.adjust(p_values, method = "bonferroni")
  truth_e0_1 <- 0 
  for (j in 1:950){
    if (p1[j]<=0.1){
      truth_e0_1=truth_e0_1+1
    }
  }
  fwer_1[i]=as.numeric(truth_e0_1>=1)
  reject_1 <- as.numeric(p1 <= alpha)
  fdr_1[i] <- ifelse(sum(reject_1[1:null_n])>0,sum(reject_1[1:null_n]) / sum(reject_1),0)
  tpr_1[i] <- sum(reject_1[(null_n+1):m]) / al_n
  #B-H
  
  p2 <- p.adjust(p_values, method = "BH")
  truth_e0_2 <- 0 
  for (j in 1:950){
    if (p2[j]<=0.1){
      truth_e0_2=truth_e0_2+1
    }
  }
  fwer_2[i]=as.numeric(truth_e0_2>=1)
  reject_2 <- as.numeric(p2 <= alpha)
  fdr_2[i] <- ifelse(sum(reject_2[1:null_n])>0,sum(reject_2[1:null_n]) / sum(reject_2),0)
  tpr_2[i] <- sum(reject_2[(null_n+1):m]) / al_n
}

results <- data.frame(
  FWER = c(mean(fwer_1),mean(fwer_2)),
  FDR = c(mean(fdr_1),mean(fdr_2)),
  TPR = c(mean(tpr_1),mean(tpr_2))
)

row.names(results) <- c("Bonferroni correction", "B-H correction")


knitr::kable(t(results))


```


## Question2
Refer to the air-conditioning data set aircondit provided in the boot package. The 12 observations are the times in hours between failures of air-conditioning equipment [68,Example 1.1]:
3,5,7,18,43,85,91.98,100,130,230,487.
Assume that the times between failures follow an exponential model Exp($\lambda$). Obtain the MLE of the hazard rate $\lambda$ and use bootstrap to estimate the bias and standard error of the estimate.

## Answer2

首先加载boot包中的数据并计算$\lambda$的最大似然估计,$e^{\lambda}$的最大似然估计$\hat\lambda_{mle} = \frac{1}{\bar x}$,则计算如下:
```{r,echo=FALSE}
rm(list = ls())

times <- c(3, 5, 7, 18, 43, 85, 91, 98, 100, 130, 230, 487)
n <- length(times) 

# 计算λ的MLE (危险率估计)
mean_t <- mean(times) 
lambda_mle <- 1/ mean_t

cat("λ的原始MLE =", round(lambda_mle, 6), "/小时\n")
```

之后再times中进行有放回的抽样,计算抽样的MLE偏差和方差，如下表所示:

```{r,echo=FALSE}


set.seed(123) 
B <- 10000   
boot_lambda <- numeric(B) 


for (i in 1:B) {
  boot_sample <- sample(times, size = n, replace = TRUE)
  boot_lambda[i] <- 1/ mean(boot_sample)
}

bias_boot <- mean(boot_lambda) - lambda_mle 
se_boot <- sd(boot_lambda)              

knitr::kable(t(
  data.frame(
    "boostrap" = mean(boot_lambda),
    "Bootstrap_bias " =bias_boot,
    "Bootstrap_sd " = se_boot
  ))
)

```


## Question3 

Refer to Exercise 8.6. Efron and Tibshirani discuss the following example [91, Chapter 7]. The five-dimensional scores data have a 5 x 5 covariance matrix $\Sigma$,with positive eigenvalues $\lambda_1>...> \lambda_5$. In principal components analysis,

$$
\theta = \frac{\lambda_1}{\sum_{i=1}^{5}\lambda_i}
$$
measures the proportion of variance explained by the first principal component.Let $\lambda_1$>...>$\lambda_5$, be the eigenvalues of $\hat\Sigma$, where $\hat\Sigma$ is the MLE of $\Sigma$. Compute the sample estimate.

$$
\hat\theta = \frac{\hat\lambda_1}{\sum_{i=1}^{5}\hat\lambda_i}
$$
of $\theta$ Use bootstrap to estimate the bias and standard error of $\hat\theta$

## Answer3

在8.6中可知,加载bootstrap包的scor数据,首先计算计算样本协方差矩阵的特征值以及样本估计值，如下:
```{r,echo=FALSE}
rm(list = ls())
library(bootstrap)
data(scor, package = "bootstrap")


Sigma_hat <- cov(scor)
eigen_values <- eigen(Sigma_hat)$values

theta_hat <- eigen_values[1] / sum(eigen_values)

knitr::kable(t(
  data.frame(
    eigen_values = eigen_values,
    theta_hat = theta_hat
  ))
)
```

使用bootstrap法从原样本中进行有放回的抽样，计算偏差估计和标准差
```{r,echo=FALSE}

B <- 10000
n <- nrow(scor)
theta_hat_b <- numeric(B)

for (i in 1:B) {

  boot_indices <- sample(1:n, size = n, replace = TRUE)
  boot_sample <- scor[boot_indices, ]

  Sigma_boot <- cov(boot_sample)
  eigen_boot <- eigen(Sigma_boot)$values
  theta_hat_b[i] <- eigen_boot[1] / sum(eigen_boot)
  
}


boot_mean <- mean(theta_hat_b)
boot_bias <- boot_mean - theta_hat
boot_se <- sd(theta_hat_b)


knitr::kable(t(
  data.frame(
    bootstrap_est = boot_mean,
    bias = boot_bias,
    sd = boot_se
  ))
)

```

