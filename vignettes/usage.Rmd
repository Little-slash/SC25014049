---
title: "Induction to SC25014049-andersonQMC"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Induction to SC25014049-andersonQMC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = TRUE)
```


## Overview
SC25014049-andersonQMC是一个R包，它通过Rcpp加速的Hirsch-Fye量子蒙特卡洛算法来研究Anderson杂质模型。该包提供了两个主要函数：simulate_hirsch_fye（R函数）和hf_step（Rcpp函数）。simulate_hirsch_fye是用户友好的模拟函数，它执行完整的蒙特卡洛模拟并返回测量结果。hf_step是核心计算函数，用C++实现，用于计算给定辅助场配置下的传播子和行列式。此外，包中还包含一个辅助函数build_hamiltonian函数，用于构建单粒子哈密顿量。通过将耗时的核心计算用C++实现，该包能够高效地进行大规模量子蒙特卡洛模拟。

## 1 simulate_hirsch_fye  Function

simulate_hirsch_fye为主模拟函数，执行完整的 Hirsch-Fye 量子蒙特卡洛模拟流程。
其主要参数有杂质能级(eps_d)、浴能级(eps_k)、杂化强度(V_k)、相互作用强度(U)、逆温度(beta)、虚时间切片数（L）、n_steps(总蒙特卡洛步数),thermal(热化步数)、measure_interval(测量间隔)等
输出为自旋向上/向下粒子数的测量序列。
其源代码实现如下：
```{r,echo=TRUE,eval=FALSE}

#' Hirsch-Fye QMC using Rcpp-accelerated core

simulate_hirsch_fye <- function(eps_d = 0, eps_k = c(-1,1), V_k = c(0.5,0.5), U = 2.0,
                                beta = 5.0, L = 40, n_steps = 20000, thermal = 2000,
                                measure_interval = 10, seed = NULL){
  if(!is.null(seed)) set.seed(seed)
  H0 <- build_hamiltonian(eps_d, eps_k, V_k)
  s <- sample(c(-1,1), L, replace = TRUE)
  
  
  meas_nup <- numeric(0)
  meas_ndn <- numeric(0)
  
  
  for(step in seq_len(n_steps)){
    l <- sample.int(L, 1)
    s_new <- s; s_new[l] <- -s_new[l]
    
    
    old <- hf_step(H0, s, U, beta)
    new <- hf_step(H0, s_new, U, beta)
    
    
    if(log(runif(1)) < (new$logdet - old$logdet)){
      s <- s_new
    }
    
    
    if (step > thermal && ((step - thermal) %% measure_interval == 0)) {
      
      cur <- hf_step(H0, s, U, beta)
      
      Gup <- solve(diag(nrow(H0)) + cur$Bup)
      Gdn <- solve(diag(nrow(H0)) + cur$Bdn)
      
      n_up <- 1 - Gup[1,1]
      n_dn <- 1 - Gdn[1,1]
      
      meas_nup <- c(meas_nup, Re(n_up))
      meas_ndn <- c(meas_ndn, Re(n_dn))
    }
  }
  
  
  list(
    measurements = list(
      n_up = meas_nup,
      n_dn = meas_ndn
    )
  )
}

```

simulate_hirsch_fye 将虚时间区间[0,β]离散为L个切片，每个切片对应一个辅助场变量$s_l$∈{−1,+1}，并初始化这些辅助场为随机配置。在蒙特卡洛采样循环中，每次迭代随机选择一个时间切片l，尝试翻转$s_l=-s_l$为了判断是否接受这一翻转，需要计算新旧配置的权重比 
$$
R = \frac{\det(I + B_\uparrow')\det(I + B_\downarrow')}{\det(I + B_\uparrow)\det(I + B_\downarrow)} 
$$
，这通过调用C++函数 hf_step 完成。在热化阶段之后，系统每隔一定步数进行物理量测量：再次调用 hf_step 获取当前辅助场配置下的 $ B_\sigma $，然后通过求解线性方程组 $(I + B_\sigma) G_\sigma = I$得到格林函数矩阵。杂质上的局域粒子数由 $ \langle n_\sigma \rangle = 1 - G_\sigma(0,0) $ 给出，因为 $ G_\sigma(0,0) $ 对应于虚时差为零时的格林函数对角元。这些测量值被累积并最终用于计算统计平均值和误差。因此，整个包通过 `simulate_hirsch_fye`作为调度器，协调`build_hamiltonian`构建单粒子基底，并反复调用`hf_step`进行核心的权重计算和格林函数构建，从而实现了从辅助场采样到物理可观测量提取的完整数值流程。


## 2 build_hamiltonian Function

build_hamiltonian Function 实现源代码如下：
```{r,echo=TRUE,eval=FALSE}

build_hamiltonian <- function(eps_d, eps_k, V_k){
  if(length(eps_k) != length(V_k)) stop("eps_k and V_k must have same length")
  n_bath <- length(eps_k)
  N <- 1 + n_bath
  H0 <- matrix(0, nrow = N, ncol = N)
  # index 1 is impurity
  H0[1,1] <- eps_d
  if(n_bath > 0){
    H0[2:(N), 2:(N)] <- diag(eps_k)
    # hybridization
    H0[1, 2:(N)] <- V_k
    H0[2:(N), 1] <- V_k
  }
  return(H0)
}

matrix_exp_dt <- function(A, dt){
  ev <- eigen(A)
  vals <- ev$values
  vecs <- ev$vectors
  expD <- diag(exp(-dt * vals))
  # reconstruct
  return(Re(vecs %*% expD %*% solve(vecs)))
}

```

build_hamiltonian 函数主要用于构建杂质+有限浴的单粒子哈密顿量矩阵。


### 使用示例

```{r,echo=TRUE}
library(SC25014049)

H0 <- build_hamiltonian(
  eps_d = 0.5,          # 杂质能级
  eps_k = c(-2, -1, 0, 1, 2),  # 5个浴能级
  V_k = rep(0.4, 5)    # 均匀杂化
)

cat("单粒子哈密顿量矩阵:\n")
print(H0)
eigenvals <- eigen(H0)$values
cat("\n哈密顿量本征值:\n")
print(round(eigenvals, 4))


plot(eigenvals, rep(1, length(eigenvals)), 
     pch = 19, col = "blue", cex = 1.5,
     xlab = "能量", ylab = "",
     main = "单粒子能级",
     yaxt = "n", ylim = c(0.5, 1.5))
abline(v = 0, lty = 2, col = "gray")

```


## BenchMarking R Vs RCPP

Rcpp源代码如下：

```{r,echo=TRUE,eval=FALSE}

// [[Rcpp::export]]
List hf_step(const NumericMatrix &H0,
             const IntegerVector &s,
             double U,
             double beta){

  int L = s.size();
  int N = H0.nrow();
  double dt = beta / L;
  
  
  NumericMatrix B0 = mat_exp(H0, dt);
  
  
  double lambda = acosh(exp(dt * U / 2.0));
  
  
  auto build_prod = [&](int spin){
    NumericMatrix M = eye(N);
    for(int l = 0; l < L; l++){
      NumericMatrix D = eye(N);
      D(0,0) = exp(spin * lambda * s[l]);
      M = matmul(matmul(D, B0), M);
    }
    return M;
  };
  NumericMatrix Bup = build_prod(+1);
  NumericMatrix Bdn = build_prod(-1);
  
  
  NumericMatrix I = eye(N);
  NumericMatrix Mup = matmul(I, I);
  NumericMatrix Mdn = matmul(I, I);
  for(int i=0;i<N;i++){
    for(int j=0;j<N;j++){
      Mup(i,j) += Bup(i,j);
      Mdn(i,j) += Bdn(i,j);
    }
  }
  
  
  double det_up = det_lu(Mup);
  double det_dn = det_lu(Mdn);
  
  
  double logdet = log(std::abs(det_up)) + log(std::abs(det_dn));
  
  
  return List::create(
    Named("Bup") = Bup,
    Named("Bdn") = Bdn,
    Named("logdet") = logdet
  );
}

```

该函数首先计算时间步长 $\Delta\tau = \beta/L $ 和变换参数 $\lambda = \cosh^{-1}(e^{\Delta\tau U/2}) $，然后构建自由传播子 $B_0 = e^{-\Delta\tau H_0} $，接着对每个自旋通道 $\sigma = \uparrow, \downarrow $ 计算时间有序乘积 $B_\sigma = \prod_{l=1}^L D_\sigma(l) B_0 $，其中 $D_\sigma(l) $ 是对角矩阵且仅杂质位有元素 $e^{\sigma \lambda s_l} $。随后计算矩阵 $M_\sigma = I + B_\sigma $ 的行列式，并返回对数权重 $\log\det = \log|\det M_\uparrow| + \log|\det M_\downarrow| $。Metropolis接受概率为 $\min(1, e^{\Delta\log\det}) $，其中 $\Delta\log\det = \log\det' - \log\det $。


```{r,echo=TRUE}
library(microbenchmark)
library(SC25014049)
#' 纯R版本的hf_step函数
#' 
#' @param H0 单粒子哈密顿量矩阵
#' @param s 辅助场配置向量
#' @param U Hubbard相互作用强度
#' @param beta 逆温度
#' @return 列表，包含Bup、Bdn和logdet
#' 

hf_step_R <- function(H0, s, U, beta) {
  L <- length(s)
  N <- nrow(H0)
  dt <- beta / L
  

  mat_exp_R <- function(A, dt) {
    ev <- eigen(A)
    vecs <- ev$vectors
    vals <- ev$values
    expD <- diag(exp(-dt * vals))
    return(Re(vecs %*% expD %*% solve(vecs)))
  }
  
  eye_R <- function(n) {
    diag(n)
  }

  det_lu_R <- function(A) {
    n <- nrow(A)
    det <- 1.0
    A_copy <- matrix(as.numeric(A), n, n)
    

    for(k in 1:(n-1)) {
      if(abs(A_copy[k, k]) < 1e-12) return(0.0)
      det <- det * A_copy[k, k]
      
      if((k+1) <= n) {  
        for(i in (k+1):n) {
          factor <- A_copy[i, k] / A_copy[k, k]

          for(j in k:n) {
            A_copy[i, j] <- A_copy[i, j] - factor * A_copy[k, j]
          }
        }
      }
    }
    
    if(n > 0) {
      det <- det * A_copy[n, n]
    }
    
    return(det)
  }
  

  B0 <- mat_exp_R(H0, dt)

  lambda <- acosh(exp(dt * U / 2.0))

  build_prod_R <- function(spin) {
    M <- eye_R(N)
    for(l in 1:L) {
      D <- eye_R(N)
      D[1, 1] <- exp(spin * lambda * s[l])
      M <- D %*% B0 %*% M
    }
    return(M)
  }
  

  Bup <- build_prod_R(+1)
  Bdn <- build_prod_R(-1)

  Mup <- diag(N) + Bup
  Mdn <- diag(N) + Bdn
  
  det_up <- det_lu_R(Mup)
  det_dn <- det_lu_R(Mdn)
  
  logdet <- log(abs(det_up)) + log(abs(det_dn))
  
  return(list(
    Bup = Bup,
    Bdn = Bdn,
    logdet = logdet
  ))
}


H0_medium <- build_hamiltonian(eps_d <- 0.0 ,eps_k <- c(-2, -1, 1, 2),V_k <- c(0.3, 0.4, 0.4, 0.3))
U_medium <- 4.0      # Hubbard相互作用
beta_medium <- 10.0   # 逆温度（对应温度T=0.1）
L_medium <- 40       # 时间切片数

set.seed(12345)
s_medium <- sample(c(-1, 1), L_medium, replace = TRUE)


benchmark_result <- microbenchmark(
  R_version = {
    result_R <- hf_step_R(H0_medium, s_medium, U_medium, beta_medium)
  },
  Rcpp_version = {
    result_cpp <- hf_step(H0_medium, s_medium, U_medium, beta_medium)
  },
    times = 100,
  unit = "ms"
)

cat("\n性能测试结果汇总:\n")

knitr::kable(summary(benchmark_result)[,c(1,3,5,6)])

benchmark_df <- as.data.frame(benchmark_result)

R_times <- benchmark_df$time[benchmark_df$expr == "R_version"] / 1e6  # 转换为毫秒
cpp_times <- benchmark_df$time[benchmark_df$expr == "Rcpp_version"] / 1e6

R_mean <- mean(R_times)
R_sd <- sd(R_times)
cpp_mean <- mean(cpp_times)
cpp_sd <- sd(cpp_times)

speedup <- R_mean / cpp_mean

cat(sprintf("R版本执行时间: %.2f ± %.2f ms\n", R_mean, R_sd))
cat(sprintf("Rcpp版本执行时间: %.2f ± %.2f ms\n", cpp_mean, cpp_sd))
cat(sprintf("加速比 (R/Rcpp): %.2f×\n", speedup))
cat(sprintf("Rcpp比R快 %.1f%%\n", (1 - 1/speedup) * 100))
```


## Quick example


```{r echo=TRUE}
library(SC25014049)

res <- simulate_hirsch_fye(
  eps_d = 0.0,
  eps_k = c(-1, 1),
  V_k = c(0.5, 0.5),
  U = 2.0,
  beta = 5.0,
  L = 40,
  n_steps = 5000,
  thermal = 500,
  measure_interval = 5,
  seed = 123
)


mean(res$measurements$n_up)
mean(res$measurements$n_dn)
plot(res$measurements$n_up, type = 'l', main = 'n_up samples')

```